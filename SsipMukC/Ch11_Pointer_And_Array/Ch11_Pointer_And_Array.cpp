#include<iostream>

using namespace std;

int main()
{
	//---------------------배열의 주소값------------------

	//int arr[10];
	//for (int i = 0; i < 10; i++)
	//{
	//	arr[i] = i + 1;
	//}
	//for (int i = 0; i < 10; i++)
	//{
	//	cout << "arr[" << i << "]의 주소값 : " << &arr[i] << '\n';
	//}
	
	//int Arr[10] = {};
	//int* pArr = &Arr[0];
	//
	//for (int i = 0; i < 10; i++)
	//{
	//	if (&Arr[i] == (pArr + i))
	//	{
	//		cout << "Arr[" << i << "]의 주소값 : " << &Arr[i] << '\n';
	//		cout << "pArr+" << i << "가 저장한 주소값 : " << pArr + i << '\n';
	//		cout << "일치"<<'\n';
	//	}
	//	else
	//		cout << "불일치";
	//}
	//pArr이라는 포인터가 +i를 하게 되면 (자료형 크기*i)만큼 주소가 커진다.

	//-------------------------포인터로 배열의 각원소에 접근해보자------------------

	//int Arr[10] = {};
	//int* pArr = &Arr[0];
	//
	//for (int i = 0; i < 10; i++)
	//{
	//	Arr[i] = i + 1;
	//}
	//
	//for (int i = 0; i < 10; i++)
	//{
	//	cout << "배열 Arr[" << i << "]의 원소 : " << Arr[i] << " / 포인터로 표현 : " << *(pArr + i) << '\n';
	//}


	//-----------------------배열 이름의 정체-----------------------

	//int arr[10] = {};
	//
	//cout << arr<<'\n';
	//cout << &arr << '\n';
	//cout << &arr[0];

	//배열 이름의 정체는 배열의 첫번째 원소의 주소이다.
	// 배열은 배열의 이름을 사용시 암묵적으로 첫번쨰 원소를 가리키는 포인터로 타입이 변환된다.
	//따라서 arr이 &arr &arr[0] 과 같은 역할을 한다.
	
	//----------------------배열과 포인터 크기는 다르다------------------

	int Array[10] = {};
	int* ptr = Array;

	cout << "배열의 크기 : " << sizeof(Array) << '\n';//얘는 (자료형 크기[4바이트] x 배열 갯수[10])이다.
	cout << "포인터의 크기 : " << sizeof(ptr) << '\n';//얘는 포인터의 크기라서 64비트에서는 8바이트가 나온다.
	cout << "Array[0]의 크기 : " << sizeof(Array[0]) << '\n';// 4바이트
	//마지막을 보면 배열의 크기와 Array[0] 크기가 다르다.
	//이것은 배열 이름과, 배열의 첫번째 원소의 주소값은 다르다는 것을 의미하는데
	//55, 57행에서 같게 나오는 것은 배열의 이름을 &이나 sizeof와 사용할때를 제외하고는
	//암묵적으로 첫번째 원소를 가리키는 포인터로 타입이 변환되기 때문이다.

	int arr[5] = { 1, 2, 3, 4, 5 };

	printf("a[3] : %d \n", arr[3]);
	printf("*(a+3) : %d \n", *(arr + 3));
	return 0;

	//따라서 arr[3]을 출력할때 주소값이 아니라 그냥 int *ptr= &a 시 *ptr 처럼 *이 없는데
	//원소 값으로 나오는 이유는 포인터로 타입이 전환되어 *(arr+3)와 같은 의미를 갖기 때문이다. 
	
}