#include<iostream>

using namespace std;

int main()
{

	//====================배열포인터=======================
	//배열 포인터는 배열을 가리키는 포인터다
	//int arr[10] = { 100,98,97,95,89,76,92,96,100,99 };
	//
	//int* parr = arr;
	//int sum = 0;
	//
	//while (parr - arr <= 9)// <<parr - arr 은 마찬가지로 *포인터의 뺄셈* 이 적용되서 (실제 주소값 차이 / (포인터 크기))>>
	//{
	//	sum += (*parr);
	//	parr++;
	//}
	//
	//printf("내 시험 점수 평균 : %d\n", sum / 10);

	//int a;
	//int *pa;
	//int **ppa;
	//
	//pa = &a;//pa는 a의 주소를 담고 있다.
	//ppa = &pa;//ppa는 pa의 주소를 담고 있다.
	//
	//a = 3;//변수 a는 3이라는 값을 담고 있다.
	////* 연산자는 주소에 저장된 실제값에 접근하게 한다.
 	//
	//printf("&a : %p // pa : %p // *ppa : %p\n", &a, pa, *ppa);
	////pa는 a의 주소를 값으로 갖고 있다.
	////ppa는 pa의 주소를 값으로 갖고 있고, *ppa는 pa 주소에 실제 담긴 값 = a의 주소를 갖고 있다.
	//printf("a : %d // *pa : %d // **ppa : %d\n", a, *pa, **ppa);
	//
	//printf("&pa : %p // ppa : %p\n", &pa, ppa);

	//int arr[3] = { 1,2,3 };
	//int(*parr)[3] = &arr;
	// 
	//printf("arr[1] : %d\n", arr[1]);
	//printf("parr[1] : %d\n", (*parr)[1]);

	//int arr[2][3];
	//
	//printf("arr[0] : %p\n", arr[0]);//& 연산자나 sizeof가 붙지 않으면, 포인터로 타입 변환 된다.
	//2차원 배열에서 arr[0]은 1차원 배열에서 arr과 같은 역할을 한다. 1차원 배열 arr=&arr / 2차원 배열 arr[0]=&arr[0][0]
	//printf("&arr[0][0] : %p\n", &arr[0][0]);//따라서 arr[0]은 arr[0][0]을 가리키는 포인터가 된다.
	//
	//printf("arr[1] : %p\n", arr[1]);
	//printf("&arr[1][0] : %p\n", &arr[1][0]);

	//따라서 sizeof에 대입해보면

	//printf("전체 크기 : %d\n", sizeof(arr));
	//printf("총 열의 개수 : %d\n", sizeof(arr[0])/sizeof(arr[0][0]));
	//printf("총 행의 개수 : %d\n", sizeof(arr) / sizeof(arr[0]));
	//2차원 배열에서 arr[0]은 1차원 배열에서 arr과 같은 역할을 한다. 1차원 배열 arr=&arr[0] / 2차원 배열 arr[0]=&arr[0][0]
	//1차원 배열 *(arr+i)=arr[i]가 느는것처럼 1차원 배열에서 arr+i는 arr[i] 원소의 메모리 배치를 나타낸다.=> int* 형으로 변한다.


	//---2차원 배열을 가리키는 포인터                      

	//int arr[2][3] = { {1,2,3},{4,5,6} };
	//int(*parr)[3];//2차원 포인터는 b 즉, 열에 대한 정보를 갖고 있어야 한다. 따라서, 
	//// 데이터형 * (* 포인터 이름)[2차원 배열의 열 개수] 형태를 갖는다.
	//
	//parr = arr;
	//
	//printf("parr[1][2] : %d, arr[1][2] : %d\n", parr[1][2], arr[1][2]);

	//2차원 배열에서 열은 행 하나의 크기를 의미하고, 주소를 구하고 싶을때는 이동한 칸수 만큼 4를 곱해주면 된다.
	// 1차원 배열에서 배열의 이름은 배열의 첫번째 원소를 가리키는 포인터(int*, 주소 ㅇㅋ 값 ㄴㄴ) 였다.
	// 2차원 배열에서 배열의 이름은 배열의 첫번째 행을 가리키는 포인터(int*, 주소 ㅇㅋ 값 ㄴㄴ) 였다. 더불어 위사례에서는 첫번째 행 크기는 3(b)이다.


	//============================포인터 배열===================================

	//포인터 배열은 정말 배열이다.

	int* arr[3];
	int a = 1, b = 2, c = 3;
	arr[0] = &a;
	arr[1] = &b;
	arr[2] = &c;

	printf("a : %d, *arr[0] : %d\n", a, *arr[0]);
	printf("b : %d, *arr[1] : %d\n", b, *arr[1]);
	printf("c : %d, *arr[2] : %d\n", c, *arr[2]);

	printf("&a : %p, arr[0] : %p\n", &a, arr[0]);


}